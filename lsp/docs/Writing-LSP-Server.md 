## How to write an LSP server

Based on DOT language extension

We can re-validate any open documents

```ts
// The settings have changed. Is send on server activation
// as well.
connection.onDidChangeConfiguration(change => {
  let settings = <Settings>change.settings;
  maxNumberOfProblems = settings.dotLanguageServer.maxNumberOfProblems || 100;
  // Revalidate any open text documents
  documents.all().forEach(validateDocument);
});
```

We need to make sure that the validation is triggered after every change of each document.
Validate active document any time it is changed

```ts
// The content of a text document has changed. This event is emitted
// when the text document first opened or when its content has changed.
documents.onDidChangeContent(change => {
  validateDocument(change.document);
});
```

We now need to define a `validateDocument` function

### Validation

We take advantage of the validation to compute which are the names (identifiers), that we store in a global variable `names`. We are going to use these names later, to satisfy requests for hover information.

The `names` will contains all our named identifiers of the current document (could also be all documents in project in some cases)

See [Diagnostic](https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.languageserver.protocol.diagnostic?view=visualstudiosdk-2017) API for more details.

```ts
let names: Array<any>;

function validateDocument(textDocument: TextDocument): void {
  let diagnostics: Diagnostic[] = [];
  let txt = textDocument.getText()

  // call parse of chevrotain
  let { messages, result } = parse(txt)

  // assuming we have a list of identifiers (for the document AST) in the result
  names = ctx.identifiers

  let problems = 0;
  for (var i = 0; i < messages.length && problems < maxNumberOfProblems; i++) {
    problems++;

    if(messages[i].length == 0)
      messages[i].length = lines[i].length - messages[i].character;

    // add diagnostics for each error
    diagnostics.push({
      severity: DiagnosticSeverity.Error,
      range: {
        start: { line: messages[i].line, character: messages[i].character},
        end: { line: messages[i].line, character: messages[i].character + messages[i].length }
      },
      message: messages[i].message,
      source: 'ex'
    });
  }
  // Send the computed diagnostics to VSCode.
  connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
});
```

Note that in the original DOT language extension, the `parse` is handled via an HTTP request to a parse server, since the parser is written in C#.

```ts
	request.post({url:'http://localhost:3000/parse', body: textDocument.getText()}, (err, httpResponse, body) => {
    const ctx = JSON.parse(body)
    names = ctx.names
  }
```

The validation will look like this in VSC:

![](./images/validate-doc.png)

The rest of the marked lines shows the gist of the communication with the client:

- we gather the diagnostic messages
- we setup them for easier use by the user
- we send them to the client.

We can choose the severity, for instance we can also simply communicate informations or warning. We must also choose a range for which the message apply, so that the user can deal with it. Sometimes this doesn’t always make sense or it’s possible, in such cases we choose as a range the rest of the line length, starting from the character that indicate the beginning of the error.

The editor will then take care of communicating the mistake to the user, usually by underlining the text. But nothing forbids the client to do something else, for instance if the client is a log manager, it could simply store the errore in some way.

## Auto-completion

Add an `onCompletion` callback that takes the current document position and returns an array of `CompletionItem`s.

![](./images/code-completion.png)

```ts
connection.onCompletion((textDocumentPosition: TextDocumentPositionParams): CompletionItem[] => {
	let text = documents.get(textDocumentPosition.textDocument.uri).getText();
	let lines = text.split(/\r?\n/g);
	let position = textDocumentPosition.position;

  let results = new Array<CompletionItem>();
```

Determine what should be suggested to complete code, based on current position.
This should be bases on the AST generated by chevrotain, which contains positions
of each literal matched

We might want to calculate a more appropriate start position for determining on which literal we are making the suggestion. We can use the position object for this as it contains the character and line number of the document

```ts
// ...

let start = 0;

for (var i = position.character; i >= 0; i--) {
  if (lines[position.line][i] == "=") {
    start = i;
    i = 0;
  }
}
```

We can then either use the AST for lookup or make a simple local string comparison,
using substr or regexp etc.

[CompletionItemKind](https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.languageserver.protocol.completionitemkind?view=visualstudiosdk-2017)

Typical kinds:

`Keyword, Text, Value, Variable, Field, Event, Constant, Class`

Example: `CompletionItemKind.Text`

```ts
let { ast, literal } = findNearestLiteral({ text, position });
```

The `label` is the suggestion. Available values loaded from a text file

See [CompletionItem](https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualstudio.languageserver.protocol.completionitem?view=visualstudiosdk-2017)

```ts
let { labels, type, kind, dataFor } = suggestionsFor({ literal, ast });

// we can then look up the list of registered suggestions for the type of literal if labels not returned directly
labels = label || labelsFor(type);
```

If the `type` is an identifier we can suggest all the names. In some cases we might several types of identifiers and the type might then have a sub type or sth.

- `type: "identifier"`
- `subtype: "class"`

The global list of `names` (or `identifiers`) might then be grouped accordingly:

```js
names = {
  classes: [
    "Account",
    "User"
    //...
  ],
  modules: [
    "Models",
    "Controllers"
    // ...
  ]
};
```

We should always send all the suggestions (labels) to the client. Visual Studio Code will filter the values considering what the user is typing.

```ts
  // ...

  labels.map(label => {
    let data = dataFor(label);
    let suggestion = {
      label,
      kind,
      data
    };

    results.push(suggestion)
  })

	return results;
}
```

`data` can be used to add meta data useful later (see `Completion resolve` below).

A typical `CompletionItem` object might look as follows

```ts
// ...
results.push({
  label, // "blue"
  kind: CompletionItemKind.Color,
  // unique id kind + label
  data: "color-" + data // blue or 17 or some other id
});
```

### Loading static suggestions

We can load static suggestions from asset/config files contained in the extension itself:

```ts
function loadColors(): Array<string> {
  let colorsFile = fs
    .readFileSync(path.join(__dirname, "..", "..", "data", "colors"))
    .toString();
  let colors = colorsFile.split(/\r?\n/g);

  return colors;
}

function loadShapes(): Array<string> {
  let shapesFile = fs
    .readFileSync(path.join(__dirname, "..", "..", "data", "shapes"))
    .toString();
  let shapes = shapesFile.split(/\r?\n/g);

  return shapes;
}
```

### Completion resolve

You may want to give additional information to the user, to make easier choosing the correct suggestion, but you can’t send too much information at once. The solution is to use another event to give the necessary information once the user has selected one suggestion.

On completion resolve we can use the `data` of the `CompletionItem` `item` to provide extra information such as:

- `detail`
- `documentation`

```ts
connection.onCompletionResolve(
  (item: CompletionItem): CompletionItem => {
    if (item.data.startsWith("color-")) {
      item.detail = "X11 Color";
      item.documentation = "http://www.graphviz.org/doc/info/colors.html";
    }

    if (item.data.startsWith("shape-")) {
      item.detail = "Shape";
      item.documentation = "http://www.graphviz.org/doc/info/shapes.html";
    }

    return item;
  }
);
```

## On hover information

An Hover Provider job is to give additional information on the text that the user is hovering on, such as the type of an object (ex. “class X”), documentation about it (ex. “The method Y is […]) or the signature of a method.
For our language server we choose to show what are the elements that can be used in a declaration. To find that information ourselves we simply use a listener when we validate the document on the service.
To communicate this information to the user, we search between the names that we have saved on the Languager Server. If we find one on the current position that the user is hovering on we tell the client, otherwise we show nothing.

```ts
connection.onHover(
  ({ textDocument, position }): Hover => {
    for (var i = 0; i < names.length; i++) {
      if (
        names[i].line == position.line &&
        (names[i].start <= position.character &&
          names[i].end >= position.character)
      ) {
        // we return an answer only if we find something
        // otherwise no hover information is given
        return {
          contents: names[i].text
        };
      }
    }
  }
);
```

## Integrating with Chevrotain parser

Chevrotain has the capability to automatically create a concrete syntax tree (CST) during parsing. A CST is a simple structure which represents the entire parse tree. It contains information on every token parsed.

The main advantage of using the automatic CST creation is that it enables writing "pure" grammars. This means that the semantic actions are not embedded into the grammar implementation but are instead completely separated from it.

```js
$.RULE("qualifiedName", () => {
  $.CONSUME(Identifier);
  $.CONSUME(Dot);
  $.CONSUME2(Identifier);
});

input = "foo.bar";

output = {
  name: "qualifiedName",
  children: {
    Dot: ["."],
    Identifier: ["foo", "bar"]
  }
};
```

Non-Terminals are handled similarly to Terminals except each item in the value's array Is the CstNode of the corresponding Grammar Rule (Non-Terminal).

```js
$.RULE("qualifiedName", () => {
  $.SUBRULE($.singleIdent);
});

$.RULE("singleIdent", () => {
  $.CONSUME(Identifier);
});

input = "foo";

output = {
  name: "qualifiedName",
  children: {
    singleIdent: [
      {
        name: "singleIdent",
        children: {
          Identifier: ["foo"]
        }
      }
    ]
  }
};
```

## How to use the parser

- Create the parser instance
- Parse the incoming text to an AST

See [Chevrotain parser tutorial](https://sap.github.io/chevrotain/docs/tutorial/step2_parsing.html#tutorial-parser)

### Parser instance

```js
// ONLY ONCE
const parser = new SelectParser([]);

function parseInput(text) {
  const lexingResult = SelectLexer.tokenize(text);
  // "input" is a setter which will reset the parser's state.
  parser.input = lexingResult.tokens;
  parser.selectStatement();

  // if (parser.errors.length > 0) {
  //   throw new Error("sad sad panda, Parsing errors detected");
  // }

  return parser;
}

const inputText = "SELECT column1 FROM table2";

// parseResult object contains: errors
const parseResult = parseInput(inputText);

return parseResult;
```

The parser only validates that the input conforms to the grammar. In most real world use cases the parser will also have to output some result or data structure.

We refer to the logic that computes that result or builds that data structure as the Grammar Semantics

The parse will generate a result containing success/error indicator.

On error, it will also contain a list of error messages including where each error was found.

```js
const interpreter = new CalculatorInterpreter();

module.exports = function(text) {
  // 1. Tokenize the input.
  const lexResult = CalculatorLexer.tokenize(text);

  // 2. Parse the Tokens vector.
  parser.input = lexResult.tokens;
  const cst = parser.expression();

  // 3. Perform semantics using a CstVisitor.
  // Note that separation of concerns between the syntactic analysis (parsing) and the semantics.
  const value = interpreter.visit(cst);

  return {
    value: value,
    lexResult: lexResult,
    parseErrors: parser.errors
  };
};
```

### Creating a Visitor to return an AST

Do we always have to implement all the visit methods?

No, sometimes we only need to handle a few specific CST Nodes In that case use `getBaseCstVisitorConstructorWithDefaults()` to get the base visitor constructor.

This base visitor includes a default implementation for all visit methods which simply invokes this.visit on all none terminals in the CSTNode's children.

```js
const BaseSQLVisitor = parserInstance.getBaseCstVisitorConstructor();

// This BaseVisitor include default visit methods that simply traverse the CST.
const BaseSQLVisitorWithDefaults = parserInstance.getBaseCstVisitorConstructorWithDefaults();

class myCustomVisitor extends BaseSQLVisitor {
  constructor() {
    super();
    // The "validateVisitor" method is a helper utility which performs static analysis
    // to detect missing or redundant visitor methods
    this.validateVisitor();
  }

  /* Visit methods go here */
}

class myCustomVisitorWithDefaults extends BaseSQLVisitorWithDefaults {
  constructor() {
    super();
    this.validateVisitor();
  }

  /* Visit methods go here */
}
```

### Adding concrete Visitor methods

Lets create a visitor method for the `selectClause` rule.

```js
class SQLToAstVisitor extends BaseSQLVisitor {
  constructor() {
    super();
    this.validateVisitor();
  }

  // The Ctx argument is the current CSTNode's children.
  selectClause(ctx) {
    // Each Terminal or Non-Terminal in a grammar rule are collected into
    // an array with the same name(key) in the ctx object.
    let columns = ctx.Identifier.map(identToken => identToken.image);

    return {
      type: "SELECT_CLAUSE",
      columns: columns
    };
  }
}
```

See [Full Visitor example](https://sap.github.io/chevrotain/docs/tutorial/step3a_adding_actions_visitor.html#full-visitor)

Using the visitor:

```js
// A new parser instance with CST output enabled.
const parserInstance = new SelectParser([], { outputCst: true });
// Our visitor has no state, so a single instance is sufficient.
const toAstVisitorInstance = new SQLToAstVisitor();

function toAst(inputText) {
  // Lex
  const lexResult = selectLexer.tokenize(inputText);
  parserInstance.input = lexResult.tokens;

  // Automatic CST created when parsing
  const cst = parserInstance.selectStatement();
  if (parserInstance.errors.length > 0) {
    throw Error(
      "Sad sad panda, parsing errors detected!\n" +
        parserInstance.errors[0].message
    );
  }

  // Visit
  const ast = toAstVisitorInstance.visit(cst);
  return ast;
}
```

Note that we might also want to return collections of some of the AST nodes visited.

```js
class SQLToAstVisitor extends BaseSQLVisitor {
  string[] tables = [];

  constructor() {
    super();
    this.validateVisitor();
  }

    fromClause(ctx) {
      const tableName = ctx.Identifier[0].image

      tables.add(tableName)

      return {
        type: "FROM_CLAUSE",
        table: tableName
      }
    }

    // ...
}

const ast = toAstVisitorInstance.visit(cst);
const { tables } = toAstVisitorInstance;
return { tables, ast};
```

### Returning Identifier nodes

We need to return the names of the identifiers that we are providing for the hover information. This is achieved either by:

- listening to the firing of the id rule.
- walking the AST and for each ID rule, fire a callback or collect the ID in a collection

The id rule might well be used to parse many different types of identifiers, such as name, attribute etc. We have to distinguish between each case to find the ones we care about and categorize them.

```
const ast = toAstVisitorInstance.visit(cst);
const { names } = toAstVisitorInstance;
return { names, ast};
```

## Leveraging chevrotain Syntactic content assist

[Syntactic content assist](https://sap.github.io/chevrotain/docs/guide/syntactic_content_assist.html)

Content assist is often used in a code Editor's context. semantic actions will normally only output useful results for valid parts of the input. Error recovery can help with invalid inputs by performing small automatic fixes to the input and more often by completely skipping (re-syncing) parts of the input until a "valid" section is encountered.

The problem is that usually the code area where content assist is requested is also currently being heavily modified by the user and is unlikely to able to be successfully parsed or automatically recovered(fixed), instead it will probably be skipped (re-synced) entirely.

What this means is that for input areas that are currently being edited (or even written from scratch) by the user semantic actions and error recovery are less relevant anyhow. And if as described in the previous section an incremental approach to using the content assist will also resolve the issue in which the content assist position follows a syntax error.

See [Example of Content assist feature](https://github.com/SAP/chevrotain/blob/master/examples/parser/content_assist/official_feature_content_assist.js)

See this [issue](https://github.com/SAP/chevrotain/issues/923) on how to understand the example and how to possibly leverage this feature!
